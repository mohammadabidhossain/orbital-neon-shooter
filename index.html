<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Orbital Neon Shooter: Redux Mobile</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; outline: none; }

        .neon-text { color: #0ff; text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff; }
        .neon-danger { color: #f00; text-shadow: 0 0 5px #f00, 0 0 10px #f00, 0 0 20px #f00; }
        .neon-warn { color: #ffaa00; text-shadow: 0 0 5px #ffaa00, 0 0 10px #ffaa00; }
        .neon-powerup { color: #ffff00; text-shadow: 0 0 5px #ffff00, 0 0 10px #ffff00; }

        @keyframes pulse-opacity {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        .animate-warn { animation: pulse-opacity 1s infinite; }

        /* Mobile specific text sizing */
        @media (max-width: 768px) {
            #heat-warning { font-size: 1.5rem; width: 100%; text-align: center; }
            #score-display { font-size: 1.5rem; }
            #start-screen h1 { font-size: 3rem; }
        }
    </style>
</head>
<body>
    <!-- UI Layer -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none hidden">
        <div class="absolute top-4 left-4">
            <h2 id="score-display" class="text-3xl font-bold text-white drop-shadow-md">SCORE: 0</h2>
            <p id="kill-count-display" class="text-sm text-gray-400">KILLS: 0</p>
        </div>
        
        <!-- Weapon Status -->
        <div class="absolute top-4 right-4 text-right">
            <div id="weapon-status" class="text-cyan-400 font-bold text-xl opacity-50">SINGLE BLASTER</div>
            <div id="next-upgrade" class="text-xs text-gray-500">NEXT UPGRADE: 10 KILLS</div>
        </div>

        <div id="heat-warning" class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-4xl font-bold neon-warn animate-warn">
            WARNING: ORBIT DECAY
        </div>

        <div class="absolute bottom-8 left-4 flex flex-col gap-2">
            <div id="shield-status" class="text-blue-400 font-bold text-xl opacity-0 transition-opacity duration-300">
                SHIELD ACTIVE
            </div>
            <div id="rapid-fire-status" class="text-yellow-400 font-bold text-xl opacity-0 transition-opacity duration-300">
                RAPID FIRE
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-50 cursor-pointer">
        <h1 class="text-6xl font-bold neon-text mb-4 text-center tracking-tighter">ORBITAL REDUX</h1>
        <p class="text-cyan-300 mb-2 text-xl">Defend the Orbit</p>
        <p id="start-high-score" class="text-yellow-500 mb-8 text-lg font-bold">BEST: 0</p>
        
        <div class="px-8 py-4 border-2 border-cyan-500 text-cyan-500 font-bold text-xl hover:bg-cyan-500 hover:text-black transition-all duration-300 animate-pulse">
            TAP TO ENGAGE
        </div>
        
        <div class="mt-8 grid grid-cols-2 gap-8 text-sm text-gray-400 text-center px-4">
            <div>
                <p class="text-white font-bold mb-1">CONTROLS</p>
                <p>WASD: Adjust Orbit</p>
                <p>Mouse: Aim & Shoot</p>
            </div>
            <div>
                <p class="text-white font-bold mb-1">UPGRADES</p>
                <p><span class="text-yellow-400">10 Kills:</span> Dual Cannons</p>
                <p><span class="text-blue-400">Blue Box:</span> Shield</p>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/85 backdrop-blur-md z-40 pointer-events-auto">
        <h1 class="text-5xl md:text-7xl font-bold neon-danger mb-2 tracking-widest text-center">SIGNAL LOST</h1>
        <p id="final-score" class="text-4xl text-white mb-2">SCORE: 0</p>
        <p id="final-high-score" class="text-xl text-yellow-500 mb-6">ALL-TIME BEST: 0</p>
        <button id="restart-btn" class="px-10 py-3 bg-red-900/50 border border-red-500 text-red-100 font-bold text-xl hover:bg-red-500 hover:text-black transition-all duration-200 pointer-events-auto uppercase tracking-wider">
            REBOOT SYSTEM
        </button>
    </div>

    <script>
        // --- CONFIG ---
        const CONFIG = {
            ARENA_SIZE: 120,
            SUN_SIZE: 18,
            PLAYER_ORBIT_RADIUS: 60,
            PLAYER_ORBIT_SPEED: 0.005,
            PLAYER_ACCEL_RADIUS: 0.3,
            ENEMY_SPEED: 1.2,
            BULLET_SPEED: 3.5,
            BULLET_COOLDOWN: 120, 
            ENEMY_SPAWN_RATE: 2000, 
            POWERUP_SPAWN_RATE: 8000,
            SHAKE_DECAY: 0.9,
            COLORS: { PLAYER: 0x00ff00, ENEMY: 0xff0000, BULLET: 0x00ffff, SUN: 0xffff00, BG: 0x000000, STAR: 0xffffff }
        };

        // --- GLOBALS ---
        let scene, camera, renderer;
        let player, sunGroup, sunCore, sunSpikes, starfield;
        let mouseRaycaster, mousePos;
        let bullets = [], enemies = [], particles = [], powerups = [];
        let keys = { w: false, a: false, s: false, d: false, space: false, mouse: false };

        let gameState = { 
            isPlaying: false, 
            score: 0, 
            highScore: 0,
            killCount: 0,
            lastShotTime: 0, 
            lastSpawnTime: 0,
            lastPowerupTime: 0,
            difficultyMult: 1.0 
        };

        let playerOrbitAngle = 0;
        let playerOrbitRadius = CONFIG.PLAYER_ORBIT_RADIUS;
        let activePowerups = { rapidFire: false, shield: false };
        let rapidFireTimer = null;
        let shakeIntensity = 0;

        // --- INIT ---
        window.onload = () => {
            initThreeJS();
            setupInputs();
            loadHighScore();
            
            document.getElementById('start-screen').addEventListener('click', (e) => {
                setTimeout(() => {
                    document.getElementById('start-screen').classList.add('hidden');
                    startGame();
                }, 100);
            });
            document.getElementById('restart-btn').addEventListener('click', (e) => {
                e.stopPropagation(); 
                resetGame();
            });
        };

        function loadHighScore() {
            const stored = localStorage.getItem('orbitalShooterHighScore');
            if (stored) {
                gameState.highScore = parseInt(stored);
            }
            document.getElementById('start-high-score').innerText = `BEST: ${gameState.highScore}`;
        }

        function saveHighScore() {
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('orbitalShooterHighScore', gameState.highScore);
            }
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.COLORS.BG);
            scene.fog = new THREE.FogExp2(CONFIG.COLORS.BG, 0.004);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(70, aspect, 0.1, 1000);
            camera.position.set(0, 140, 0);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            document.body.appendChild(renderer.domElement);

            mouseRaycaster = new THREE.Raycaster();
            mousePos = new THREE.Vector2();

            createWorld();
            requestAnimationFrame(gameLoop);
        }

        function createWorld() {
            // --- FEROCIOUS SUN ---
            sunGroup = new THREE.Group();
            scene.add(sunGroup);

            // 1. Core
            const sunGeo = new THREE.SphereGeometry(CONFIG.SUN_SIZE, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                emissive: 0xff4400, 
                emissiveIntensity: 2 
            });
            sunCore = new THREE.Mesh(sunGeo, sunMat);
            sunGroup.add(sunCore);
            
            // 2. Spiky Corona (The "Ferocious" part)
            const spikesGeo = new THREE.IcosahedronGeometry(CONFIG.SUN_SIZE * 1.1, 1);
            const spikesMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                emissive: 0xff0000, 
                emissiveIntensity: 1,
                wireframe: true 
            });
            sunSpikes = new THREE.Mesh(spikesGeo, spikesMat);
            sunGroup.add(sunSpikes);

            // 3. Halo
            const haloGeo = new THREE.SphereGeometry(CONFIG.SUN_SIZE * 1.4, 32, 32);
            const haloMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.15, side: THREE.BackSide });
            const halo = new THREE.Mesh(haloGeo, haloMat);
            sunGroup.add(halo);

            // Starfield
            const starGeo = new THREE.BufferGeometry();
            const starCount = 800;
            const posArray = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                posArray[i] = (Math.random() - 0.5) * 400; 
                if (i % 3 === 1) posArray[i] = (Math.random() - 0.5) * 50 - 50; 
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starMat = new THREE.PointsMaterial({ size: 0.8, color: CONFIG.COLORS.STAR, transparent: true, opacity: 0.6 });
            starfield = new THREE.Points(starGeo, starMat);
            scene.add(starfield);

            // Player
            const pGeo = new THREE.TetrahedronGeometry(1.5);
            const pMat = new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.PLAYER, wireframe: true });
            const pCore = new THREE.Mesh(new THREE.TetrahedronGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            player = new THREE.Group();
            player.add(new THREE.Mesh(pGeo, pMat));
            player.add(pCore);
            
            // Shield
            const shieldGeo = new THREE.SphereGeometry(2.5, 16, 16);
            const shieldMat = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.3, wireframe: true });
            const shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
            shieldMesh.name = 'shield';
            shieldMesh.visible = false;
            player.add(shieldMesh);

            player.position.set(CONFIG.PLAYER_ORBIT_RADIUS, 0, 0); 
            scene.add(player);
        }

        // --- GAMEPLAY ---
        function startGame() {
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.killCount = 0;
            gameState.lastSpawnTime = Date.now();
            gameState.lastPowerupTime = Date.now();
            gameState.difficultyMult = 1.0;
            
            playerOrbitAngle = 0;
            playerOrbitRadius = CONFIG.PLAYER_ORBIT_RADIUS;
            player.position.set(playerOrbitRadius, 0, 0);
            
            activePowerups.shield = false;
            activePowerups.rapidFire = false;
            
            document.getElementById('ui-layer').classList.remove('hidden');
            updateUI();
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            // Animate Sun (Always animate)
            sunCore.rotation.y += 0.005;
            sunSpikes.rotation.y -= 0.01;
            sunSpikes.rotation.z += 0.005;
            
            // Sun Pulse
            const pulseScale = 1 + Math.sin(Date.now() * 0.003) * 0.05;
            sunCore.scale.setScalar(pulseScale);
            sunSpikes.scale.setScalar(pulseScale * 1.05);

            if (gameState.isPlaying) {
                const now = Date.now();

                // 1. Difficulty & Sun Aggression
                gameState.difficultyMult = 1 + Math.min(gameState.score / 5000, 1.5); 
                
                // Sun gets redder and bigger as difficulty increases
                const dangerLevel = Math.min((gameState.difficultyMult - 1), 1); // 0 to 1
                sunCore.material.color.setHSL(0.08 - (dangerLevel * 0.08), 1, 0.5); // Yellow to Red
                sunSpikes.material.color.setHSL(0 - (dangerLevel * 0.1), 1, 0.5); // Red to Deep Red
                const angryScale = 1 + (dangerLevel * 0.3);
                sunGroup.scale.setScalar(angryScale);


                // 2. Player Movement
                let orbitSpeed = CONFIG.PLAYER_ORBIT_SPEED;
                
                let inputX = 0; // Orbit speed mod
                let inputY = 0; // Radius mod

                if (keys.a) inputX = 1;
                if (keys.d) inputX = -1;
                if (keys.w) inputY = -1;
                if (keys.s) inputY = 1;

                playerOrbitAngle += (orbitSpeed + (inputX * 0.01)); 
                playerOrbitRadius += (inputY * CONFIG.PLAYER_ACCEL_RADIUS);
                
                // Sun size affects safe zone
                const currentSunRadius = CONFIG.SUN_SIZE * angryScale;
                playerOrbitRadius = THREE.MathUtils.clamp(playerOrbitRadius, currentSunRadius + 4, CONFIG.ARENA_SIZE * 1.5);

                player.position.x = Math.cos(playerOrbitAngle) * playerOrbitRadius;
                player.position.z = Math.sin(playerOrbitAngle) * playerOrbitRadius;
                player.rotation.y = -playerOrbitAngle; 

                // 3. Heat Warning
                const heatWarningEl = document.getElementById('heat-warning');
                if (playerOrbitRadius < currentSunRadius + 15) {
                    heatWarningEl.classList.remove('hidden');
                } else {
                    heatWarningEl.classList.add('hidden');
                }

                // 4. Aiming
                const vector = new THREE.Vector3(mousePos.x, mousePos.y, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.y / dir.y;
                const targetPoint = camera.position.clone().add(dir.multiplyScalar(distance));
                
                if (targetPoint) {
                    targetPoint.y = player.position.y;
                    player.lookAt(targetPoint);
                }

                // 5. Shooting
                const currentCooldown = activePowerups.rapidFire ? CONFIG.BULLET_COOLDOWN / 3 : CONFIG.BULLET_COOLDOWN;
                const isTryingToShoot = keys.space || keys.mouse;

                if (isTryingToShoot && (now - gameState.lastShotTime > currentCooldown)) {
                    // DOUBLE GUN CHECK
                    if (gameState.killCount >= 10) {
                        fireBullet(-0.6); // Left offset
                        fireBullet(0.6);  // Right offset
                    } else {
                        fireBullet(0);    // Center
                    }
                    gameState.lastShotTime = now;
                }

                // 6. Spawning
                const currentSpawnRate = Math.max(600, CONFIG.ENEMY_SPAWN_RATE / gameState.difficultyMult);
                if (now - gameState.lastSpawnTime > currentSpawnRate) {
                    spawnEnemy();
                    gameState.lastSpawnTime = now;
                }

                if (now - gameState.lastPowerupTime > CONFIG.POWERUP_SPAWN_RATE) {
                    if (Math.random() > 0.3) spawnPowerup();
                    gameState.lastPowerupTime = now;
                }

                updateEntities();
            }

            // Camera Shake
            if (shakeIntensity > 0) {
                const rx = (Math.random() - 0.5) * shakeIntensity;
                const rz = (Math.random() - 0.5) * shakeIntensity;
                camera.position.set(rx, 140, rz);
                shakeIntensity *= CONFIG.SHAKE_DECAY;
                if (shakeIntensity < 0.1) {
                    shakeIntensity = 0;
                    camera.position.set(0, 140, 0);
                }
            }

            renderer.render(scene, camera);
        }

        function fireBullet(offsetSide = 0) {
            const geo = new THREE.SphereGeometry(0.5, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ 
                color: activePowerups.rapidFire ? 0xffff00 : CONFIG.COLORS.BULLET, 
                emissive: activePowerups.rapidFire ? 0xffff00 : CONFIG.COLORS.BULLET, 
                emissiveIntensity: 2 
            });
            const bullet = new THREE.Mesh(geo, mat);
            
            // Calculate offset position relative to player rotation
            const offsetVector = new THREE.Vector3(offsetSide, 0, 0).applyQuaternion(player.quaternion);
            bullet.position.copy(player.position).add(offsetVector);
            
            const dir = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion);
            bullet.userData = { velocity: dir.multiplyScalar(CONFIG.BULLET_SPEED) };
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        function spawnEnemy() {
            const geo = new THREE.OctahedronGeometry(1.4);
            const mat = new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.ENEMY, wireframe: true });
            const enemy = new THREE.Mesh(geo, mat);
            
            const angle = Math.random() * Math.PI * 2;
            const radius = CONFIG.ARENA_SIZE * 1.5;
            enemy.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
            
            enemy.userData = { rotSpeed: Math.random() * 0.1 + 0.02 };
            scene.add(enemy);
            enemies.push(enemy);
        }

        function spawnPowerup() {
            const type = Math.random() > 0.5 ? 'rapid' : 'shield';
            const color = type === 'rapid' ? 0xffff00 : 0x0088ff;
            
            const geo = new THREE.BoxGeometry(2, 2, 2);
            const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true, emissive: color, emissiveIntensity: 0.5 });
            const powerup = new THREE.Mesh(geo, mat);

            const angle = Math.random() * Math.PI * 2;
            const radius = CONFIG.SUN_SIZE + 20 + Math.random() * 60;
            powerup.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
            
            powerup.userData = { type: type, rotSpeed: 0.05 };
            scene.add(powerup);
            powerups.push(powerup);
        }

        function updateEntities() {
            // Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.add(b.userData.velocity);
                if (b.position.length() > CONFIG.ARENA_SIZE * 2 || b.position.distanceTo(sunGroup.position) < CONFIG.SUN_SIZE) {
                    scene.remove(b); bullets.splice(i, 1);
                }
            }

            // Powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.rotation.x += p.userData.rotSpeed;
                p.rotation.y += p.userData.rotSpeed;

                if (p.position.distanceTo(player.position) < 3) {
                    activatePowerup(p.userData.type);
                    scene.remove(p);
                    powerups.splice(i, 1);
                    createExplosion(p.position, p.material.color, 5);
                }
            }

            // Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                
                const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                const speed = CONFIG.ENEMY_SPEED * 0.15 * (gameState.difficultyMult); 
                e.position.add(dir.multiplyScalar(speed + 0.15)); 
                
                e.lookAt(player.position); 
                e.rotation.z += e.userData.rotSpeed;

                // Check Sun Collision
                const currentSunRadius = CONFIG.SUN_SIZE * sunGroup.scale.x;
                if (e.position.distanceTo(sunGroup.position) < currentSunRadius + 2) {
                    createExplosion(e.position, CONFIG.COLORS.SUN, 8);
                    shakeIntensity = 0.5;
                    scene.remove(e); enemies.splice(i, 1);
                    continue;
                }

                // Player Collision
                if (e.position.distanceTo(player.position) < 2.5) {
                    if (activePowerups.shield) {
                        activePowerups.shield = false;
                        player.getObjectByName('shield').visible = false;
                        createExplosion(e.position, 0x0088ff, 15); 
                        shakeIntensity = 2;
                        scene.remove(e); enemies.splice(i, 1);
                        updateUI();
                    } else {
                        createExplosion(player.position, CONFIG.COLORS.PLAYER, 20);
                        endGame();
                        return;
                    }
                }

                // Bullet Collision
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const b = bullets[j];
                    if (b && e.position.distanceTo(b.position) < 2.5) {
                        createExplosion(e.position, CONFIG.COLORS.ENEMY, 10);
                        shakeIntensity = 0.8; 
                        scene.remove(e); enemies.splice(i, 1);
                        scene.remove(b); bullets.splice(j, 1);
                        updateScore(100);
                        
                        // KILL COUNT LOGIC
                        gameState.killCount++;
                        updateUI();
                        
                        break;
                    }
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.material.opacity -= 0.03;
                p.scale.multiplyScalar(0.95);
                if (p.material.opacity <= 0) {
                    scene.remove(p); particles.splice(i, 1);
                }
            }

            // Player Sun Death
            const currentSunRadius = CONFIG.SUN_SIZE * sunGroup.scale.x;
            if (playerOrbitRadius < currentSunRadius + 1.5) {
                if (activePowerups.shield) {
                    playerOrbitRadius += 10; 
                    activePowerups.shield = false;
                    player.getObjectByName('shield').visible = false;
                    shakeIntensity = 5;
                    updateUI();
                } else {
                    createExplosion(player.position, CONFIG.COLORS.SUN, 30);
                    endGame();
                }
            }
        }

        function activatePowerup(type) {
            if (type === 'shield') {
                activePowerups.shield = true;
                player.getObjectByName('shield').visible = true;
            } else if (type === 'rapid') {
                activePowerups.rapidFire = true;
                clearTimeout(rapidFireTimer);
                rapidFireTimer = setTimeout(() => {
                    activePowerups.rapidFire = false;
                    updateUI();
                }, 5000);
            }
            updateUI();
        }

        function createExplosion(pos, color, count) {
            for(let k=0; k<count; k++) {
                const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const mat = new THREE.MeshBasicMaterial({color: color, transparent: true, emissive: color});
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                
                const speed = Math.random() * 0.8 + 0.2;
                p.userData.vel = new THREE.Vector3(
                    (Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)
                ).normalize().multiplyScalar(speed);
                
                scene.add(p);
                particles.push(p);
            }
        }

        function updateScore(points) {
            gameState.score += points;
            updateUI();
        }

        function updateUI() {
            document.getElementById('score-display').innerText = `SCORE: ${gameState.score}`;
            document.getElementById('kill-count-display').innerText = `KILLS: ${gameState.killCount}`;
            
            // Weapon UI Update
            const weaponStatus = document.getElementById('weapon-status');
            const nextUpgrade = document.getElementById('next-upgrade');
            if (gameState.killCount >= 10) {
                weaponStatus.innerText = "DUAL CANNONS";
                weaponStatus.classList.add("text-yellow-400");
                weaponStatus.classList.remove("text-cyan-400", "opacity-50");
                nextUpgrade.classList.add("hidden");
            } else {
                weaponStatus.innerText = "SINGLE BLASTER";
                weaponStatus.classList.remove("text-yellow-400");
                weaponStatus.classList.add("text-cyan-400", "opacity-50");
                nextUpgrade.classList.remove("hidden");
                nextUpgrade.innerText = `NEXT UPGRADE: ${10 - gameState.killCount} KILLS`;
            }

            const shieldEl = document.getElementById('shield-status');
            shieldEl.style.opacity = activePowerups.shield ? '1' : '0';

            const rapidEl = document.getElementById('rapid-fire-status');
            rapidEl.style.opacity = activePowerups.rapidFire ? '1' : '0';
        }

        function endGame() {
            gameState.isPlaying = false;
            saveHighScore();
            document.getElementById('final-score').innerText = `SCORE: ${gameState.score}`;
            document.getElementById('final-high-score').innerText = `ALL-TIME BEST: ${gameState.highScore}`;
            document.getElementById('game-over-modal').classList.remove('hidden');
            document.getElementById('ui-layer').classList.add('hidden');
        }

        function resetGame() {
            enemies.forEach(e => scene.remove(e)); enemies = [];
            bullets.forEach(b => scene.remove(b)); bullets = [];
            particles.forEach(p => scene.remove(p)); particles = [];
            powerups.forEach(p => scene.remove(p)); powerups = [];
            
            document.getElementById('game-over-modal').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            startGame();
        }

        // --- INPUTS ---
        function setupInputs() {
            window.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                if(key === 'w') keys.w = true;
                if(key === 'a') keys.a = true;
                if(key === 's') keys.s = true;
                if(key === 'd') keys.d = true;
                if(key === ' ') keys.space = true;
            });
            window.addEventListener('keyup', e => {
                const key = e.key.toLowerCase();
                if(key === 'w') keys.w = false;
                if(key === 'a') keys.a = false;
                if(key === 's') keys.s = false;
                if(key === 'd') keys.d = false;
                if(key === ' ') keys.space = false;
            });
            window.addEventListener('mousemove', e => {
                mousePos.x = (e.clientX / window.innerWidth) * 2 - 1;
                mousePos.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            window.addEventListener('mousedown', () => keys.mouse = true);
            window.addEventListener('mouseup', () => keys.mouse = false);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
